---
phase: 03-schedule-execution-tool-hardening
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - gathering/core/tool_registry.py
  - gathering/skills/registry.py
  - gathering/skills/base.py
  - gathering/api/routers/workspace.py
autonomous: true

must_haves:
  truths:
    - "A tool invoked with parameters violating its JSON schema is rejected before execution with a descriptive validation error"
    - "Validation error messages include which parameter failed and why"
    - "Async tools (async_function=True) are awaited, not called synchronously"
    - "Sync tools called from async context run in executor to avoid blocking the event loop"
    - "SkillRegistry.execute_tool validates input against skill tool input_schema before execution"
    - "Workspace API resolves file paths relative to project directory from DB, not os.getcwd()"
  artifacts:
    - path: "gathering/core/tool_registry.py"
      provides: "JSON Schema validation in execute() and new execute_async() method"
      contains: "jsonschema.validate"
    - path: "gathering/skills/registry.py"
      provides: "JSON Schema validation in execute_tool before skill.execute"
      contains: "jsonschema.validate"
    - path: "gathering/skills/base.py"
      provides: "True async execution path for async skills"
      contains: "run_in_executor"
    - path: "gathering/api/routers/workspace.py"
      provides: "Project path resolution from DB or WORKSPACE_ROOT"
      contains: "WORKSPACE_ROOT"
  key_links:
    - from: "gathering/core/tool_registry.py"
      to: "jsonschema"
      via: "validate() call before tool.function()"
      pattern: "jsonschema\\.validate.*tool\\.function"
    - from: "gathering/skills/registry.py"
      to: "jsonschema"
      via: "validate() call before skill.execute()"
      pattern: "jsonschema\\.validate.*skill\\.execute"
    - from: "gathering/api/routers/workspace.py"
      to: "circle.projects or WORKSPACE_ROOT"
      via: "DB lookup or env var for project path"
      pattern: "WORKSPACE_ROOT|projects.*WHERE.*id"
---

<objective>
Harden tool registries with JSON Schema validation and async execution, and fix workspace path resolution.

Purpose: Tools currently execute without parameter validation and ignore the async_function flag. The workspace API resolves all paths against os.getcwd(). This plan adds jsonschema validation to both ToolRegistry and SkillRegistry, implements proper async/sync tool execution paths, and fixes workspace path resolution.

Output: Both registries validate parameters before execution, async tools run without blocking, and workspace resolves project-specific paths.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-schedule-execution-tool-hardening/03-RESEARCH.md
@gathering/core/tool_registry.py
@gathering/skills/registry.py
@gathering/skills/base.py
@gathering/api/routers/workspace.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add JSON Schema validation and async execution to ToolRegistry and SkillRegistry</name>
  <files>gathering/core/tool_registry.py, gathering/skills/registry.py, gathering/skills/base.py</files>
  <action>
**Step 0: Install jsonschema.**
Run `pip install jsonschema` and verify it installs. Add `jsonschema` to requirements if a requirements.txt or pyproject.toml [dependencies] section exists (check first with grep).

**Step 1: Harden ToolRegistry.execute() with validation.**

In `gathering/core/tool_registry.py`:

1. Add import at top: `import jsonschema` (guarded with try/except ImportError for graceful degradation if not installed).
2. In `execute()` method, BEFORE calling `tool.function(**kwargs)`:
   - If `tool.parameters` is a non-empty dict, call `jsonschema.validate(instance=kwargs, schema=tool.parameters)`.
   - Catch `jsonschema.ValidationError` and raise `ValueError` with a descriptive message: `f"Invalid parameters for tool '{tool_name}': {e.message} (at {'.'.join(str(p) for p in e.absolute_path)})"`. Include `e.absolute_path` for which parameter failed and `e.message` for what's wrong.
   - Catch `jsonschema.SchemaError` and log warning (don't reject -- schema itself is malformed, not user's fault).

3. Add `async execute_async(self, tool_name: str, **kwargs) -> Any` method:
   - Same validation logic as execute().
   - If `tool.async_function` is True: `return await tool.function(**kwargs)`
   - If `tool.async_function` is False: `return await asyncio.get_event_loop().run_in_executor(None, lambda: tool.function(**kwargs))`
   - Add `import asyncio` at top.

4. Update sync `execute()` to handle async_function flag:
   - If `tool.async_function` is True, raise `RuntimeError("Async tool '{tool_name}' must be called via execute_async()")` -- sync callers should not silently block on async tools.

5. Update the module-level `execute_tool()` convenience function to remain sync (calls `execute()` -- only sync tools).

**Step 2: Add validation to SkillRegistry.execute_tool().**

In `gathering/skills/registry.py`:

1. Add import: `import jsonschema` (guarded).
2. In `execute_tool()` method, AFTER finding the skill and BEFORE calling `skill.execute()`:
   - Get the skill's tool definitions: `tool_defs = skill.get_tools_definition()`
   - Find the matching tool def: `tool_def = next((t for t in tool_defs if t["name"] == tool_name), None)`
   - If `tool_def` and `tool_def.get("input_schema")`:
     - `jsonschema.validate(instance=tool_input, schema=tool_def["input_schema"])`
     - Catch `jsonschema.ValidationError` and return `SkillResponse(success=False, message=f"Invalid parameters for tool '{tool_name}': {e.message}", error="validation_error")`
3. Add `execute_tool_async()` classmethod that mirrors `execute_tool()` but calls `skill.execute_async(tool_name, tool_input)` instead of `skill.execute()`.

**Step 3: Improve BaseSkill.execute_async() default implementation.**

In `gathering/skills/base.py`:

1. Update the default `execute_async()` to run sync `execute()` in an executor to avoid blocking:
   ```python
   async def execute_async(self, tool_name: str, tool_input: Dict[str, Any]) -> SkillResponse:
       import asyncio
       loop = asyncio.get_event_loop()
       return await loop.run_in_executor(None, self.execute, tool_name, tool_input)
   ```
   This ensures that skills which don't override execute_async still don't block the event loop.

IMPORTANT: The jsonschema import should be guarded with try/except ImportError so the module doesn't crash if jsonschema isn't installed -- log a warning and skip validation.
  </action>
  <verify>
Run `python -c "import jsonschema; print('jsonschema version:', jsonschema.__version__)"` -- confirms installed.
Run `python -c "
from gathering.core.tool_registry import ToolRegistry, ToolDefinition, ToolCategory
reg = ToolRegistry()
reg.register(ToolDefinition(
    name='test_tool',
    description='Test',
    category=ToolCategory.UTILITY,
    function=lambda x: x,
    required_competencies=[],
    parameters={'type': 'object', 'properties': {'x': {'type': 'integer'}}, 'required': ['x']},
    returns={},
))
try:
    reg.execute('test_tool', x='not_an_int')
    print('FAIL: should have raised')
except ValueError as e:
    print('OK: validation caught:', e)
"` -- should print validation error about type.
Run `python -c "
from gathering.core.tool_registry import ToolRegistry, ToolDefinition, ToolCategory
reg = ToolRegistry()
reg.register(ToolDefinition(
    name='test_tool',
    description='Test',
    category=ToolCategory.UTILITY,
    function=lambda x: x * 2,
    required_competencies=[],
    parameters={'type': 'object', 'properties': {'x': {'type': 'integer'}}, 'required': ['x']},
    returns={},
))
result = reg.execute('test_tool', x=5)
print('OK: result =', result)
"` -- should print 10.
  </verify>
  <done>
ToolRegistry.execute() validates kwargs against tool.parameters JSON Schema before execution. ToolRegistry.execute_async() handles async/sync tools properly. SkillRegistry.execute_tool() validates tool_input against input_schema. BaseSkill.execute_async() runs sync execute in executor. Invalid parameters produce descriptive error messages with parameter path and violation description.
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix workspace path resolution</name>
  <files>gathering/api/routers/workspace.py</files>
  <action>
Replace the `get_project_path()` function that returns `os.getcwd()` with real project path resolution.

1. **Check if a projects table exists** by searching the DB schema files for a `projects` table with a `path` column. The `001_complete_schema.sql` has `circle.projects` -- check its columns.

2. **Implement get_project_path() with layered resolution:**

   ```python
   def get_project_path(project_id: int) -> str:
       """Resolve project workspace path.

       Resolution order:
       1. Database: circle.projects.workspace_path for this project_id
       2. Environment: WORKSPACE_ROOT / project subdirectory
       3. Fallback: current working directory (with deprecation warning)
       """
       # Try database lookup
       try:
           from gathering.api.dependencies import get_database_service
           db = get_database_service()
           if db:
               row = db.execute_one(
                   "SELECT workspace_path FROM circle.projects WHERE id = %(id)s",
                   {"id": project_id},
               )
               if row and row.get("workspace_path"):
                   path = row["workspace_path"]
                   if os.path.isdir(path):
                       return path
                   logger.warning("Project %d workspace_path '%s' does not exist", project_id, path)
       except Exception as e:
           logger.debug("DB lookup for project path failed: %s", e)

       # Try WORKSPACE_ROOT env var
       workspace_root = os.environ.get("WORKSPACE_ROOT")
       if workspace_root:
           project_dir = os.path.join(workspace_root, str(project_id))
           if os.path.isdir(project_dir):
               return project_dir
           # Try workspace root itself if project subdir doesn't exist
           if os.path.isdir(workspace_root):
               return workspace_root

       # Fallback to cwd with warning
       logger.warning(
           "Project %d: no workspace_path in DB and WORKSPACE_ROOT not set, "
           "falling back to cwd. Set WORKSPACE_ROOT env var or update project config.",
           project_id,
       )
       return os.getcwd()
   ```

3. **Adapt for actual DB schema.** The `circle.projects` table may not have a `workspace_path` column. Check the schema:
   - If `workspace_path` column exists: use it directly.
   - If not but a `path` or `root_path` column exists: use that.
   - If no path column exists at all: rely on WORKSPACE_ROOT env var as primary method and skip the DB lookup (just log debug message). Do NOT add a migration -- Phase 3 is about making existing things work, not schema changes. The WORKSPACE_ROOT approach is sufficient.

4. **Ensure the function is efficient** -- it's called on every workspace endpoint. If doing DB lookup, consider a simple module-level LRU cache (functools.lru_cache won't work due to unhashable db, but a simple dict cache with TTL will):
   ```python
   _project_path_cache: Dict[int, tuple[str, float]] = {}
   _CACHE_TTL = 300  # 5 minutes
   ```
   Check cache first, only query DB if cache miss or expired.
  </action>
  <verify>
Run `python -c "from gathering.api.routers.workspace import get_project_path; import os; os.environ['WORKSPACE_ROOT'] = '/tmp'; path = get_project_path(999); print('path:', path); assert path != '' "` -- should return /tmp or cwd fallback.
Run `grep -c 'os.getcwd' gathering/api/routers/workspace.py` -- should be 1 (only in the fallback path, not as the primary return).
Run `grep -c 'WORKSPACE_ROOT' gathering/api/routers/workspace.py` -- should be >= 1.
  </verify>
  <done>
get_project_path() resolves paths from DB (if workspace_path column exists) or WORKSPACE_ROOT env var, with cwd as last-resort fallback with deprecation warning. All workspace API endpoints now resolve against the correct project directory when properly configured.
  </done>
</task>

</tasks>

<verification>
1. `pip show jsonschema` -- package installed
2. `python -c "from gathering.core.tool_registry import ToolRegistry; print(hasattr(ToolRegistry, 'execute_async'))"` -- True
3. `python -c "from gathering.skills.registry import SkillRegistry; print('execute_tool_async' in dir(SkillRegistry))"` -- True
4. `grep 'jsonschema' gathering/core/tool_registry.py gathering/skills/registry.py` -- validation present in both
5. `grep 'run_in_executor' gathering/skills/base.py` -- async default uses executor
6. `grep 'WORKSPACE_ROOT' gathering/api/routers/workspace.py` -- env var resolution present
</verification>

<success_criteria>
- jsonschema installed and importable
- ToolRegistry.execute() rejects invalid params with descriptive ValidationError
- ToolRegistry.execute() accepts valid params and returns tool result
- ToolRegistry.execute_async() awaits async tools and wraps sync tools in executor
- SkillRegistry.execute_tool() validates against input_schema before calling skill.execute()
- BaseSkill.execute_async() default runs sync execute in executor
- get_project_path() uses DB lookup or WORKSPACE_ROOT, not just os.getcwd()
- Fallback to os.getcwd() only happens with warning log
</success_criteria>

<output>
After completion, create `.planning/phases/03-schedule-execution-tool-hardening/03-02-SUMMARY.md`
</output>
