---
phase: 01-auth-security-foundation
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - gathering/utils/sql.py
  - gathering/api/routers/pipelines.py
  - gathering/api/routers/projects.py
  - gathering/api/dependencies.py
  - gathering/api/routers/workspace.py
  - gathering/api/middleware.py
  - gathering/core/exceptions.py
  - tests/test_security.py
  - tests/test_auth_persistence.py
autonomous: true

must_haves:
  truths:
    - "No SQL query in the codebase constructs SET clauses using f-strings -- all use safe_update_builder with column allowlists"
    - "File-serving endpoints reject encoded path traversal attempts (%2e%2e/, double-encoded, symlink escape) and return 403"
    - "Bare exception catches in auth.py, dependencies.py, middleware.py, and workspace.py security paths are replaced with specific exception types"
    - "Tests prove SQL injection via column injection is impossible (safe_update_builder rejects unknown columns)"
    - "Tests prove path traversal is blocked for ../, %2e%2e/, double-encoded paths, and symlink escapes"
    - "Tests prove auth token lifecycle (creation, expiry, blacklist, concurrent use)"
    - "Tests prove database persistence (user survives conceptual restart)"
  artifacts:
    - path: "gathering/utils/sql.py"
      provides: "safe_update_builder function for validated dynamic UPDATE queries"
      contains: "def safe_update_builder"
    - path: "gathering/api/routers/workspace.py"
      provides: "Hardened file serving with URL decoding, .. rejection, symlink check"
      contains: "unquote"
    - path: "tests/test_security.py"
      provides: "Tests for SQL safety, path traversal prevention, constant-time auth"
      contains: "test_path_traversal"
    - path: "tests/test_auth_persistence.py"
      provides: "Tests for auth token lifecycle and DB persistence"
      contains: "test_token_blacklist"
  key_links:
    - from: "gathering/api/routers/pipelines.py"
      to: "gathering/utils/sql.py"
      via: "safe_update_builder replaces f-string SET construction"
      pattern: "safe_update_builder"
    - from: "gathering/api/routers/projects.py"
      to: "gathering/utils/sql.py"
      via: "safe_update_builder replaces f-string SET construction"
      pattern: "safe_update_builder"
    - from: "gathering/api/dependencies.py"
      to: "gathering/utils/sql.py"
      via: "safe_update_builder replaces f-string SET construction in update_conversation"
      pattern: "safe_update_builder"
    - from: "gathering/api/routers/workspace.py"
      to: "urllib.parse.unquote"
      via: "URL decoding before path resolution"
      pattern: "unquote"
---

<objective>
Harden security: formalize SQL dynamic UPDATE patterns with safe_update_builder, prevent path traversal with URL decoding and symlink checks, replace bare exceptions in security-critical paths with specific error handling, and write comprehensive tests for auth lifecycle, persistence, SQL safety, and path traversal.

Purpose: Satisfies success criteria #3 (no f-string SQL with user values), #5 (path traversal returns 403), and requirements RLBL-01 (bare exception fixes in security paths), TEST-01 (auth token lifecycle tests), TEST-03 (DB persistence tests). Also covers SEC-03 formalization.

Output: safe_update_builder utility, hardened workspace router, cleaned exception handling, comprehensive test suite for security and auth.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-auth-security-foundation/01-RESEARCH.md
@.planning/phases/01-auth-security-foundation/01-01-SUMMARY.md

@gathering/api/routers/pipelines.py
@gathering/api/routers/projects.py
@gathering/api/routers/workspace.py
@gathering/api/dependencies.py
@gathering/api/middleware.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: SQL safety formalization and path traversal hardening</name>
  <files>
    gathering/utils/__init__.py
    gathering/utils/sql.py
    gathering/api/routers/pipelines.py
    gathering/api/routers/projects.py
    gathering/api/dependencies.py
    gathering/api/routers/workspace.py
  </files>
  <action>
    **Step 1: Create gathering/utils/sql.py with safe_update_builder.**

    Create `gathering/utils/__init__.py` (empty file if it does not exist).

    Create `gathering/utils/sql.py`:
    ```python
    """
    SQL safety utilities for GatheRing.
    Provides helpers to build dynamic SQL safely with column allowlists.
    """

    from typing import Any, Optional


    def safe_update_builder(
        allowed_columns: set[str],
        updates: dict[str, Any],
        always_set: Optional[dict[str, str]] = None,
    ) -> tuple[str, dict]:
        """Build a safe SET clause from allowed column names.

        All column names are validated against the allowlist. Values are
        parameterized using %(param)s placeholders (psycopg named params).

        Args:
            allowed_columns: Set of column names allowed in SET clause.
            updates: Dict of {column_name: value} from caller (may include user input keys).
            always_set: Dict of {column_name: raw_sql_expression} always appended
                        (e.g., {"updated_at": "CURRENT_TIMESTAMP"}). These are NOT parameterized.

        Returns:
            Tuple of (SET clause string, params dict).

        Raises:
            ValueError: If any column name is not in the allowlist.

        Example:
            >>> clause, params = safe_update_builder(
            ...     {"name", "description", "status"},
            ...     {"name": "New Name", "status": "active"},
            ...     always_set={"updated_at": "CURRENT_TIMESTAMP"},
            ... )
            >>> clause
            'name = %(name)s, status = %(status)s, updated_at = CURRENT_TIMESTAMP'
        """
        set_parts: list[str] = []
        params: dict[str, Any] = {}

        for col, val in updates.items():
            if col not in allowed_columns:
                raise ValueError(
                    f"Column {col!r} not in allowed columns: {sorted(allowed_columns)}"
                )
            set_parts.append(f"{col} = %({col})s")
            params[col] = val

        if always_set:
            for col, expr in always_set.items():
                set_parts.append(f"{col} = {expr}")

        return ", ".join(set_parts), params
    ```

    **Step 2: Replace f-string UPDATE in gathering/api/routers/pipelines.py.**

    Find the `update_pipeline` function. It currently builds a SET clause using `f"UPDATE circle.pipelines SET {', '.join(updates)} WHERE id = %(id)s RETURNING *"`.

    Refactor to use safe_update_builder:
    - Add import: `from gathering.utils.sql import safe_update_builder`
    - Identify the allowed columns for pipeline updates (look at what the function allows: typically `name`, `description`, `config`, `status`, etc.)
    - Build the update dict from the request data
    - Call `safe_update_builder(PIPELINE_UPDATE_COLUMNS, update_dict, always_set={"updated_at": "CURRENT_TIMESTAMP"})`
    - Use the returned clause and params in the SQL

    The key pattern transformation is:
    ```python
    # BEFORE:
    updates = []
    params = {"id": pipeline_id}
    if data.name is not None:
        updates.append("name = %(name)s")
        params["name"] = data.name
    # ... more fields ...
    updates.append("updated_at = CURRENT_TIMESTAMP")
    sql = f"UPDATE circle.pipelines SET {', '.join(updates)} WHERE id = %(id)s RETURNING *"

    # AFTER:
    PIPELINE_UPDATE_COLUMNS = {"name", "description", "config", "status", "is_active"}
    update_dict = {}
    if data.name is not None:
        update_dict["name"] = data.name
    # ... more fields ...
    if not update_dict:
        return await get_pipeline(pipeline_id, db)
    set_clause, params = safe_update_builder(
        PIPELINE_UPDATE_COLUMNS, update_dict,
        always_set={"updated_at": "CURRENT_TIMESTAMP"},
    )
    params["id"] = pipeline_id
    sql = f"UPDATE circle.pipelines SET {set_clause} WHERE id = %(id)s RETURNING *"
    ```

    **Step 3: Replace f-string UPDATE in gathering/api/routers/projects.py.**

    Same pattern as pipelines. Find the update function, identify allowed columns for project updates, use safe_update_builder.

    **Step 4: Replace f-string UPDATE in gathering/api/dependencies.py.**

    The `update_conversation` method in `DatabaseService` has the same pattern. Apply safe_update_builder. Identify allowed columns from the conversation table schema.

    Add import: `from gathering.utils.sql import safe_update_builder`

    **Step 5: Harden path traversal in gathering/api/routers/workspace.py.**

    Find the file-serving endpoint(s) (the `get_file_raw` function around line 155-225). Replace the current path validation with a robust `validate_file_path` helper:

    At the top of workspace.py, add:
    ```python
    from urllib.parse import unquote

    def validate_file_path(project_path: str, user_path: str) -> Path:
        """Validate and resolve a user-provided file path.

        Returns resolved path if safe, raises HTTPException(403) if traversal detected.
        Handles: ../, %2e%2e/, double-encoded paths, symlink escapes.
        """
        # Step 1: URL-decode (double decode for double-encoding attacks)
        decoded_path = unquote(unquote(user_path))

        # Step 2: Reject any '..' components (before and after decoding)
        if ".." in decoded_path:
            raise HTTPException(status_code=403, detail="Path traversal detected")

        # Step 3: Resolve absolute paths
        project_root = Path(project_path).resolve()
        target = (project_root / decoded_path).resolve()

        # Step 4: Verify target is within project root
        try:
            target.relative_to(project_root)
        except ValueError:
            raise HTTPException(status_code=403, detail="Access denied: path outside project")

        # Step 5: Check for symlink escape
        if target.is_symlink():
            real_target = Path(os.readlink(target)).resolve() if target.exists() else target.resolve()
            try:
                real_target.relative_to(project_root)
            except ValueError:
                raise HTTPException(status_code=403, detail="Access denied: symlink escape")

        return target
    ```

    Add `import os` if not already imported.

    Then update the file-serving endpoint to use `validate_file_path()` instead of the inline path resolution:
    ```python
    full_path = validate_file_path(project_path, path)
    ```

    Remove the old inline security check block (the nested try/except with resolve/relative_to).

    Also apply `validate_file_path()` to ALL file-serving endpoints in workspace.py that accept a user-provided path (read_file, get_file_raw, write_file, delete_file, etc.). Search for `Path(project_path) / path` patterns and replace each with `validate_file_path(project_path, path)`.

    **Step 6: Fix bare exceptions in security-critical paths.**

    Target files for Tier 1 (security paths only, ~30 catches):

    In **gathering/api/middleware.py** (1 bare except):
    - Line 243: Replace `except Exception as e:` with specific exceptions. Check what can fail in the request logging middleware and catch `(ValueError, AttributeError, RuntimeError)` or appropriate types. Log unexpected exceptions with `logger.exception()`.

    In **gathering/api/routers/workspace.py** (~20 bare excepts):
    - These are in endpoint functions. For each `except Exception as e: raise HTTPException(status_code=500, detail=str(e))`:
      - Change to `except (OSError, IOError, PermissionError) as e:` for file operation errors
      - Add a separate `except Exception as e: logger.exception(f"Unexpected error in {endpoint_name}"); raise HTTPException(status_code=500, detail="Internal server error")`
      - Do NOT expose raw exception messages in 500 responses -- use generic "Internal server error" message

    In **gathering/api/dependencies.py** (~15 bare excepts in the skill/tool execution paths):
    - Focus ONLY on the ones in security-relevant code paths (database operations, auth-related queries)
    - Leave skill execution bare excepts alone (those are for isolation and will be fixed in Phase 2-3)
    - For database operation bare excepts: catch `psycopg.Error` (or the appropriate psycopg exception) and `ValueError`

    In **gathering/api/auth.py** (if any remain after Plan 02 work):
    - Any remaining bare excepts should be narrowed to `(PyJWTError, ValueError, KeyError)` as appropriate

    **CRITICAL RULE for bare exception fixes:**
    - Change ONE function at a time
    - Run tests after each change
    - If a bare except was suppressing a real bug, the test will fail -- that is the correct behavior
    - Some bare excepts in EventBus handlers are INTENTIONAL (isolation). Do NOT touch those.
    - Add a comment `# Intentional: isolate handler failures` where bare excepts are kept by design
  </action>
  <verify>
    Run `pytest tests/ -x -v --timeout=60` -- all existing tests pass.
    Run `grep -rn 'f"UPDATE.*\{' gathering/api/routers/pipelines.py gathering/api/routers/projects.py gathering/api/dependencies.py` -- no matches (f-string UPDATE eliminated).
    Run `python -c "from gathering.utils.sql import safe_update_builder; clause, params = safe_update_builder({'name','status'}, {'name':'x'}); print(clause, params)"` -- prints valid SET clause.
    Run `python -c "from gathering.utils.sql import safe_update_builder; safe_update_builder({'name'}, {'evil_col': 'x'})"` -- raises ValueError.
  </verify>
  <done>All f-string UPDATE patterns replaced with safe_update_builder. Path traversal defense handles URL encoding, double encoding, .., and symlinks with 403 responses. Bare exceptions in security paths (auth, middleware, workspace, dependencies) replaced with specific exception types. EventBus isolation bare excepts preserved with comments.</done>
</task>

<task type="auto">
  <name>Task 2: Comprehensive security and auth tests</name>
  <files>
    tests/test_security.py
    tests/test_auth_persistence.py
  </files>
  <action>
    **Step 1: Create tests/test_security.py with SQL safety and path traversal tests.**

    ```python
    """
    Security tests for Phase 1: Auth + Security Foundation.
    Tests SQL injection prevention, path traversal defense, and constant-time auth.
    """

    import os
    import pytest
    from pathlib import Path
    from unittest.mock import patch, MagicMock

    from gathering.utils.sql import safe_update_builder


    class TestSafeUpdateBuilder:
        """Tests for SQL safe_update_builder utility."""

        def test_valid_columns_accepted(self):
            """Allowed columns produce valid SET clause."""
            clause, params = safe_update_builder(
                {"name", "description", "status"},
                {"name": "Test", "status": "active"},
            )
            assert "name = %(name)s" in clause
            assert "status = %(status)s" in clause
            assert params == {"name": "Test", "status": "active"}

        def test_invalid_column_rejected(self):
            """Columns not in allowlist raise ValueError."""
            with pytest.raises(ValueError, match="not in allowed columns"):
                safe_update_builder(
                    {"name", "description"},
                    {"name": "Test", "evil_injection": "DROP TABLE"},
                )

        def test_always_set_appended(self):
            """always_set expressions are included in clause."""
            clause, params = safe_update_builder(
                {"name"},
                {"name": "Test"},
                always_set={"updated_at": "CURRENT_TIMESTAMP"},
            )
            assert "updated_at = CURRENT_TIMESTAMP" in clause
            assert "name = %(name)s" in clause
            assert "updated_at" not in params  # Not parameterized

        def test_empty_updates_produces_empty_clause(self):
            """Empty updates dict produces empty clause."""
            clause, params = safe_update_builder({"name"}, {})
            assert clause == ""
            assert params == {}

        def test_sql_injection_via_column_name_blocked(self):
            """SQL injection attempt via column name is rejected."""
            with pytest.raises(ValueError):
                safe_update_builder(
                    {"name"},
                    {"name; DROP TABLE users--": "value"},
                )

        def test_special_characters_in_values_safe(self):
            """Special characters in values are safely parameterized."""
            clause, params = safe_update_builder(
                {"name"},
                {"name": "'; DROP TABLE users;--"},
            )
            assert params["name"] == "'; DROP TABLE users;--"
            assert "%(name)s" in clause  # Parameterized, not inlined


    class TestPathTraversalPrevention:
        """Tests for workspace path traversal defense."""

        def setup_method(self):
            """Set up test fixtures."""
            # Import here to avoid import errors if workspace not available
            from gathering.api.routers.workspace import validate_file_path
            self.validate = validate_file_path
            self.project_root = os.getcwd()

        def test_normal_path_accepted(self):
            """Normal relative paths within project are accepted."""
            # Use a path that actually exists
            result = self.validate(self.project_root, "pyproject.toml")
            assert result.exists()

        def test_dot_dot_slash_rejected(self):
            """Basic ../ traversal is rejected with 403."""
            from fastapi import HTTPException
            with pytest.raises(HTTPException) as exc_info:
                self.validate(self.project_root, "../../../etc/passwd")
            assert exc_info.value.status_code == 403

        def test_encoded_dot_dot_rejected(self):
            """URL-encoded %2e%2e/ traversal is rejected with 403."""
            from fastapi import HTTPException
            with pytest.raises(HTTPException) as exc_info:
                self.validate(self.project_root, "%2e%2e/%2e%2e/etc/passwd")
            assert exc_info.value.status_code == 403

        def test_double_encoded_dot_dot_rejected(self):
            """Double URL-encoded (%252e%252e/) traversal is rejected with 403."""
            from fastapi import HTTPException
            with pytest.raises(HTTPException) as exc_info:
                self.validate(self.project_root, "%252e%252e/%252e%252e/etc/passwd")
            assert exc_info.value.status_code == 403

        def test_mixed_encoding_rejected(self):
            """Mixed encoding (..%2f) traversal is rejected with 403."""
            from fastapi import HTTPException
            with pytest.raises(HTTPException) as exc_info:
                self.validate(self.project_root, "..%2f..%2fetc/passwd")
            assert exc_info.value.status_code == 403

        def test_backslash_traversal_rejected(self):
            """Backslash-based traversal is rejected."""
            from fastapi import HTTPException
            with pytest.raises(HTTPException) as exc_info:
                self.validate(self.project_root, "..\\..\\etc\\passwd")
            assert exc_info.value.status_code == 403
    ```

    **Step 2: Create tests/test_auth_persistence.py with auth lifecycle and persistence tests.**

    ```python
    """
    Auth persistence and lifecycle tests for Phase 1.
    Tests token creation, expiry, blacklist, concurrent use, and database persistence.
    """

    import pytest
    import time
    from datetime import timedelta
    from unittest.mock import patch, MagicMock

    from gathering.api.auth import (
        create_access_token,
        decode_token,
        get_password_hash,
        verify_password,
        blacklist_token,
        is_token_blacklisted,
        _get_token_hash,
        TokenBlacklist,
        ALGORITHM,
    )


    class TestTokenLifecycle:
        """Tests for auth token creation, validation, expiry, and blacklist (TEST-01)."""

        def test_token_creation_with_valid_data(self):
            """Token creation produces a decodable JWT."""
            token = create_access_token({"sub": "user123", "email": "test@test.com", "role": "user"})
            assert token is not None
            assert isinstance(token, str)
            assert len(token) > 0

        def test_token_decode_returns_correct_data(self):
            """Decoded token contains the original payload."""
            token = create_access_token({"sub": "user123", "email": "test@test.com", "role": "user"})
            # Decode without blacklist check (no DB in unit tests)
            data = decode_token(token, check_blacklist=False)
            assert data is not None
            assert data.sub == "user123"
            assert data.email == "test@test.com"
            assert data.role == "user"

        def test_token_expiry(self):
            """Expired token returns None on decode."""
            token = create_access_token(
                {"sub": "user123", "email": "test@test.com", "role": "user"},
                expires_delta=timedelta(seconds=-1),  # Already expired
            )
            data = decode_token(token, check_blacklist=False)
            assert data is None

        def test_token_with_custom_expiry(self):
            """Token with custom expiry is valid before expiry."""
            token = create_access_token(
                {"sub": "user123", "email": "test@test.com", "role": "user"},
                expires_delta=timedelta(hours=1),
            )
            data = decode_token(token, check_blacklist=False)
            assert data is not None
            assert data.exp is not None

        def test_token_with_invalid_signature_rejected(self):
            """Token with wrong signature returns None."""
            import jwt as pyjwt
            token = pyjwt.encode({"sub": "user123"}, "wrong-key", algorithm="HS256")
            data = decode_token(token, check_blacklist=False)
            assert data is None

        def test_token_without_sub_rejected(self):
            """Token missing 'sub' claim returns None."""
            from gathering.api.auth import get_secret_key
            import jwt as pyjwt
            token = pyjwt.encode({"email": "test@test.com"}, get_secret_key(), algorithm="HS256")
            data = decode_token(token, check_blacklist=False)
            assert data is None

        def test_multiple_tokens_for_same_user(self):
            """Multiple tokens for the same user are all independently valid (multi-device)."""
            token1 = create_access_token({"sub": "user123", "email": "test@test.com", "role": "user"})
            token2 = create_access_token({"sub": "user123", "email": "test@test.com", "role": "user"})
            assert token1 != token2  # Different tokens (different exp timestamps)
            assert decode_token(token1, check_blacklist=False) is not None
            assert decode_token(token2, check_blacklist=False) is not None


    class TestTokenBlacklistUnit:
        """Unit tests for TokenBlacklist class (in-memory layer only, no DB)."""

        def setup_method(self):
            """Create a fresh TokenBlacklist with mocked DB."""
            self.mock_db = MagicMock()
            self.mock_db.execute.return_value = []
            self.mock_db.execute_one.return_value = None
            self.blacklist = TokenBlacklist(db=self.mock_db, cache_max_size=100)

        def test_blacklist_adds_to_cache(self):
            """Blacklisting a token adds it to the in-memory cache."""
            future_exp = time.time() + 3600
            self.blacklist.blacklist("hash123", future_exp, user_id="user1")
            assert self.blacklist.is_blacklisted("hash123") is True

        def test_blacklist_writes_to_db(self):
            """Blacklisting a token writes through to database."""
            future_exp = time.time() + 3600
            self.blacklist.blacklist("hash123", future_exp, user_id="user1")
            self.mock_db.execute.assert_called_once()
            call_args = self.mock_db.execute.call_args
            assert "auth.token_blacklist" in call_args[0][0]

        def test_expired_token_not_blacklisted(self):
            """Token with past expiry is not considered blacklisted."""
            past_exp = time.time() - 3600
            self.blacklist.blacklist("hash_expired", past_exp)
            assert self.blacklist.is_blacklisted("hash_expired") is False

        def test_cache_evicts_oldest_when_full(self):
            """Cache evicts oldest entry when max size exceeded."""
            small_blacklist = TokenBlacklist(db=self.mock_db, cache_max_size=3)
            future_exp = time.time() + 3600
            small_blacklist.blacklist("hash1", future_exp)
            small_blacklist.blacklist("hash2", future_exp)
            small_blacklist.blacklist("hash3", future_exp)
            small_blacklist.blacklist("hash4", future_exp)  # Should evict hash1
            assert small_blacklist._cache.__len__() == 3

        def test_db_fallback_when_not_in_cache(self):
            """When token not in cache, checks DB."""
            self.mock_db.execute_one.return_value = {"exp": time.time() + 3600}
            result = self.blacklist.is_blacklisted("not_in_cache")
            self.mock_db.execute_one.assert_called_once()
            assert result is True

        def test_db_miss_returns_false(self):
            """When token not in cache or DB, returns False."""
            self.mock_db.execute_one.return_value = None
            result = self.blacklist.is_blacklisted("nowhere")
            assert result is False

        def test_db_result_promoted_to_cache(self):
            """Token found in DB is promoted to cache for future lookups."""
            self.mock_db.execute_one.return_value = {"exp": time.time() + 3600}
            self.blacklist.is_blacklisted("db_token")
            # Second lookup should use cache (no additional DB call)
            self.blacklist.is_blacklisted("db_token")
            assert self.mock_db.execute_one.call_count == 1

        def test_stats_returns_cache_info(self):
            """Stats include cache size info."""
            stats = self.blacklist.get_stats()
            assert "cache_size" in stats
            assert "cache_max_size" in stats


    class TestPasswordHashingCompatibility:
        """Tests that bcrypt direct hashing is compatible with passlib-generated hashes."""

        def test_bcrypt_hash_format(self):
            """Hash format is standard bcrypt $2b$."""
            hashed = get_password_hash("test_password")
            assert hashed.startswith("$2b$")

        def test_verify_against_known_bcrypt_hash(self):
            """Can verify against a known bcrypt hash (simulating passlib-generated hash)."""
            # This hash was generated by passlib for "test_password"
            # bcrypt hashes from passlib use $2b$ prefix and are compatible
            hashed = get_password_hash("test_password")
            assert verify_password("test_password", hashed) is True
            assert verify_password("wrong_password", hashed) is False

        def test_hash_uniqueness(self):
            """Same password produces different hashes (random salt)."""
            h1 = get_password_hash("same_password")
            h2 = get_password_hash("same_password")
            assert h1 != h2
            assert verify_password("same_password", h1)
            assert verify_password("same_password", h2)
    ```

    **Step 3: Run the full test suite and fix any failures.**

    Run: `cd /home/loc/workspace/gathering && pytest tests/test_security.py tests/test_auth_persistence.py tests/test_auth.py -v`

    If any test fails:
    - Read the failure message
    - Fix the implementation code (not the test) if the test correctly describes expected behavior
    - Fix the test only if the test itself has a bug (wrong import, wrong assumption about API)
    - Re-run until green

    Also run: `pytest tests/ -x --timeout=60` to ensure no regressions in the broader test suite.

    **IMPORTANT testing constraints:**
    - Tests that need a database use mocks (MagicMock for DatabaseService) -- do NOT require a live PostgreSQL instance for unit tests
    - Integration tests that verify actual DB persistence are clearly marked and may be skipped in CI without PostgreSQL
    - Use `@pytest.mark.skipif` or `@pytest.mark.integration` for tests requiring live DB
  </action>
  <verify>
    Run `pytest tests/test_security.py -v` -- all security tests pass.
    Run `pytest tests/test_auth_persistence.py -v` -- all auth lifecycle tests pass.
    Run `pytest tests/test_auth.py -v` -- existing auth tests still pass.
    Run `pytest tests/ -x --timeout=60` -- no regressions in full suite.
    Run `grep -rn 'f"UPDATE.*\{' gathering/api/routers/ gathering/api/dependencies.py` -- no matches.
  </verify>
  <done>safe_update_builder replaces all f-string UPDATE patterns. Path traversal defense handles .., %2e%2e, double encoding, and symlinks. Bare exceptions in security paths are narrowed to specific types. Comprehensive test suite covers: SQL injection prevention, path traversal blocking, token lifecycle (creation, expiry, blacklist, multi-device), password hashing compatibility, and TokenBlacklist cache behavior.</done>
</task>

</tasks>

<verification>
1. `grep -rn 'f"UPDATE.*{' gathering/api/routers/ gathering/api/dependencies.py` returns no matches
2. All path traversal test variants (../, %2e%2e/, double-encoded, symlinks) return 403
3. `safe_update_builder` rejects columns not in allowlist (ValueError)
4. Token lifecycle tests pass: creation, expiry, blacklist, concurrent tokens, invalid signature
5. TokenBlacklist unit tests pass: cache add, DB write-through, eviction, DB fallback, promotion
6. Password hashing tests pass: format, verification, uniqueness
7. Full test suite passes with no regressions
</verification>

<success_criteria>
- No f-string SQL UPDATE construction remains in pipelines.py, projects.py, or dependencies.py
- Path traversal returns 403 for ../, %2e%2e/, double-encoded, and symlink escape attempts
- Bare exceptions in auth.py, middleware.py, workspace.py, and dependencies.py security paths replaced with specific types
- test_security.py has 10+ tests covering SQL safety and path traversal
- test_auth_persistence.py has 15+ tests covering token lifecycle and blacklist behavior
- All existing tests pass with zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/01-auth-security-foundation/01-03-SUMMARY.md`
</output>
