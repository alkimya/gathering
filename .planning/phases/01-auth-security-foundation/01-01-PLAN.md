---
phase: 01-auth-security-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pyproject.toml
  - gathering/api/auth.py
  - gathering/core/exceptions.py
  - gathering/core/logging.py
  - gathering/db/migrations/006_auth_users.sql
  - gathering/api/main.py
autonomous: true

must_haves:
  truths:
    - "PyJWT encodes/decodes tokens identically to python-jose (existing tokens still validate)"
    - "bcrypt.checkpw verifies passwords hashed by passlib CryptContext (existing hashes still work)"
    - "structlog produces JSON log output with request correlation IDs"
    - "auth.users and auth.token_blacklist tables exist in PostgreSQL after migration"
    - "AuthenticationError and AuthorizationError exception classes exist in the hierarchy"
  artifacts:
    - path: "pyproject.toml"
      provides: "Updated dependencies (PyJWT, structlog, asgi-correlation-id added; python-jose, passlib removed; bcrypt unpinned)"
      contains: "PyJWT"
    - path: "gathering/api/auth.py"
      provides: "JWT operations via PyJWT, password hashing via bcrypt direct"
      contains: "import jwt"
    - path: "gathering/core/exceptions.py"
      provides: "AuthenticationError, AuthorizationError, DatabaseError subclasses"
      contains: "class AuthenticationError"
    - path: "gathering/core/logging.py"
      provides: "structlog configuration with JSON output and correlation ID support"
      contains: "structlog.configure"
    - path: "gathering/db/migrations/006_auth_users.sql"
      provides: "auth.users and auth.token_blacklist table definitions"
      contains: "CREATE TABLE auth.users"
    - path: "gathering/api/main.py"
      provides: "structlog initialization and correlation ID middleware on app startup"
      contains: "configure_logging"
  key_links:
    - from: "gathering/api/auth.py"
      to: "jwt (PyJWT)"
      via: "import jwt replacing from jose import jwt"
      pattern: "import jwt"
    - from: "gathering/api/auth.py"
      to: "bcrypt"
      via: "bcrypt.hashpw/checkpw replacing passlib CryptContext"
      pattern: "bcrypt\\.checkpw"
    - from: "gathering/api/main.py"
      to: "gathering/core/logging.py"
      via: "configure_logging() call at startup"
      pattern: "configure_logging"
---

<objective>
Swap authentication libraries (python-jose to PyJWT, passlib to direct bcrypt), add new exception classes, configure structured logging with correlation IDs, create database migration for auth tables, and update project dependencies.

Purpose: Establish the foundation that Plans 02 and 03 build on -- library APIs, DB tables, logging infrastructure, and exception types must exist before auth persistence and security hardening work begins.

Output: Updated auth.py using PyJWT/bcrypt, new logging.py, new migration SQL, extended exceptions.py, updated pyproject.toml.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-auth-security-foundation/01-RESEARCH.md

@gathering/api/auth.py
@gathering/core/exceptions.py
@gathering/core/config.py
@gathering/api/main.py
@gathering/db/migrations/001_complete_schema.sql
@gathering/db/migrations/archive/008_audit_schema.sql
@pyproject.toml
@tests/test_auth.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Library swap -- PyJWT, bcrypt direct, dependency updates</name>
  <files>
    pyproject.toml
    gathering/api/auth.py
    tests/test_auth.py
  </files>
  <action>
    **Step 1: Update pyproject.toml dependencies.**

    In `[tool.poetry.dependencies]`, make these changes:
    - Replace `python-jose = {extras = ["cryptography"], version = "^3.3"}` with `PyJWT = {extras = ["crypto"], version = ">=2.9"}`
    - Replace `passlib = {extras = ["bcrypt"], version = "^1.7"}` with nothing (remove the line)
    - Change `bcrypt = ">=4.0.0,<4.1.0"` to `bcrypt = ">=4.0.0"` (unpin upper bound)
    - Add `asgi-correlation-id = ">=4.0"` in the Utilities section
    - Verify `structlog = "^24.0"` already exists (it does -- no change needed)

    **Step 2: Install/update dependencies.**
    Run: `cd /home/loc/workspace/gathering && poetry lock --no-update && poetry install`
    Then uninstall removed packages: `pip uninstall python-jose passlib ecdsa rsa pyasn1 -y 2>/dev/null; true`

    **Step 3: Swap JWT library in gathering/api/auth.py.**
    - Replace `from jose import JWTError, jwt` with `import jwt` and `from jwt.exceptions import PyJWTError`
    - In `create_access_token()`: `jwt.encode(to_encode, get_secret_key(), algorithm=ALGORITHM)` -- API is identical, no change needed in the call itself
    - In `decode_token()`: Replace `except JWTError:` with `except PyJWTError:`
    - In `blacklist_token()`: Replace `except JWTError:` with `except PyJWTError:`

    **Step 4: Swap password hashing in gathering/api/auth.py.**
    - Remove `from passlib.context import CryptContext` and `pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")`
    - Add `import bcrypt` at the top imports
    - Replace `verify_password()`:
      ```python
      def verify_password(plain_password: str, hashed_password: str) -> bool:
          """Verify a password against its hash."""
          return bcrypt.checkpw(
              plain_password.encode("utf-8"),
              hashed_password.encode("utf-8"),
          )
      ```
    - Replace `get_password_hash()`:
      ```python
      def get_password_hash(password: str) -> str:
          """Hash a password using bcrypt."""
          return bcrypt.hashpw(
              password.encode("utf-8"),
              bcrypt.gensalt(),
          ).decode("utf-8")
      ```

    **Step 5: Update admin password hash generation docstring.**
    In `get_admin_from_env()` docstring, replace the passlib-based hash generation command with:
    `python -c "import bcrypt; print(bcrypt.hashpw(b'your-password', bcrypt.gensalt()).decode())"`

    **Step 6: Update tests/test_auth.py.**
    - The test imports should not change (they import `get_password_hash`, `verify_password`, etc. from `gathering.api.auth`)
    - Verify existing tests still pass with the new implementations (bcrypt hash format `$2b$` is identical)
    - If tests import `JWTError` anywhere, update to `PyJWTError`

    **CRITICAL: Backward compatibility.**
    - Existing bcrypt hashes (format `$2b$12$...`) are fully compatible with direct bcrypt library
    - JWT token format is unchanged (HS256 + same secret key)
    - All function signatures remain identical
    - User ID format remains `str` (per locked decision)
  </action>
  <verify>
    Run `cd /home/loc/workspace/gathering && python -c "import jwt; print(jwt.__version__)"` -- should print PyJWT version (2.9+).
    Run `python -c "import bcrypt; print(bcrypt.__version__)"` -- should print 4.x.
    Run `python -c "from jose import jwt" 2>&1` -- should fail (python-jose removed).
    Run `python -c "from passlib.context import CryptContext" 2>&1` -- should fail (passlib removed).
    Run `pytest tests/test_auth.py -v` -- all existing auth tests pass.
  </verify>
  <done>PyJWT replaces python-jose, direct bcrypt replaces passlib, all existing auth tests pass, bcrypt upper bound unpinned, python-jose and passlib fully removed.</done>
</task>

<task type="auto">
  <name>Task 2: Exception classes, structured logging, and auth migration SQL</name>
  <files>
    gathering/core/exceptions.py
    gathering/core/logging.py
    gathering/db/migrations/006_auth_users.sql
    gathering/api/main.py
  </files>
  <action>
    **Step 1: Add exception classes to gathering/core/exceptions.py.**
    Add three new exception subclasses BEFORE the backward compatibility aliases section:

    ```python
    class AuthenticationError(GatheringError):
        """Raised when authentication fails (invalid credentials, expired token, etc.)."""
        def __init__(self, message: str, reason: Optional[str] = None):
            details = {}
            if reason:
                details["reason"] = reason
            super().__init__(message, details)
            self.reason = reason

    class AuthorizationError(GatheringError):
        """Raised when an authenticated user lacks permission for an action."""
        def __init__(self, message: str, required_role: Optional[str] = None, user_role: Optional[str] = None):
            details = {}
            if required_role:
                details["required_role"] = required_role
            if user_role:
                details["user_role"] = user_role
            super().__init__(message, details)
            self.required_role = required_role
            self.user_role = user_role

    class DatabaseError(GatheringError):
        """Raised when database operations fail unexpectedly."""
        def __init__(self, message: str, operation: Optional[str] = None, table: Optional[str] = None):
            details = {}
            if operation:
                details["operation"] = operation
            if table:
                details["table"] = table
            super().__init__(message, details)
            self.operation = operation
            self.table = table
    ```

    Also update the module docstring to include the new classes.

    **Step 2: Create gathering/core/logging.py.**
    New file implementing structured logging configuration:

    ```python
    """
    Structured logging configuration for GatheRing.
    Configures structlog with JSON output and request correlation ID support.
    """

    import logging
    import structlog


    def configure_logging(json_output: bool = True, log_level: str = "INFO") -> None:
        """Configure structlog for GatheRing application.

        Args:
            json_output: If True, output JSON logs. If False, use console renderer (dev mode).
            log_level: Root log level (DEBUG, INFO, WARNING, ERROR).
        """
        shared_processors = [
            structlog.contextvars.merge_contextvars,
            structlog.stdlib.add_logger_name,
            structlog.stdlib.add_log_level,
            structlog.stdlib.PositionalArgumentsFormatter(),
            structlog.processors.TimeStamper(fmt="iso"),
            structlog.processors.StackInfoRenderer(),
            structlog.processors.UnicodeDecoder(),
        ]

        if json_output:
            renderer = structlog.processors.JSONRenderer()
        else:
            renderer = structlog.dev.ConsoleRenderer()

        structlog.configure(
            processors=[
                *shared_processors,
                structlog.stdlib.ProcessorFormatter.wrap_for_formatter,
            ],
            logger_factory=structlog.stdlib.LoggerFactory(),
            wrapper_class=structlog.stdlib.BoundLogger,
            cache_logger_on_first_use=True,
        )

        formatter = structlog.stdlib.ProcessorFormatter(
            processors=[
                structlog.stdlib.ProcessorFormatter.remove_processors_meta,
                renderer,
            ],
        )

        handler = logging.StreamHandler()
        handler.setFormatter(formatter)

        root_logger = logging.getLogger()
        # Remove existing handlers to avoid duplicate output
        root_logger.handlers.clear()
        root_logger.addHandler(handler)
        root_logger.setLevel(getattr(logging, log_level.upper(), logging.INFO))
    ```

    **Step 3: Create gathering/db/migrations/006_auth_users.sql.**
    New migration file with auth tables. Use the schema from research, but also ensure the audit.security_events table exists (CREATE IF NOT EXISTS since it may exist from 008_audit_schema.sql in archive):

    ```sql
    -- Migration 006: Auth Users and Token Blacklist
    -- Phase 1: Auth + Security Foundation
    -- Creates persistent storage for user accounts and revoked tokens

    -- Ensure auth schema exists
    CREATE SCHEMA IF NOT EXISTS auth;
    CREATE SCHEMA IF NOT EXISTS audit;

    -- =============================================================================
    -- auth.users - Persistent user accounts
    -- =============================================================================

    CREATE TABLE IF NOT EXISTS auth.users (
        id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
        external_id VARCHAR(36) NOT NULL UNIQUE DEFAULT gen_random_uuid()::text,
        email VARCHAR(255) NOT NULL,
        email_lower VARCHAR(255) GENERATED ALWAYS AS (LOWER(email)) STORED,
        name VARCHAR(100) NOT NULL,
        password_hash VARCHAR(72) NOT NULL,
        role VARCHAR(20) NOT NULL DEFAULT 'user',
        is_active BOOLEAN NOT NULL DEFAULT TRUE,
        created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
        updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );

    CREATE UNIQUE INDEX IF NOT EXISTS idx_auth_users_email_lower ON auth.users(email_lower);
    CREATE INDEX IF NOT EXISTS idx_auth_users_external_id ON auth.users(external_id);

    -- Updated_at trigger (reuse public.update_updated_at if exists, otherwise create)
    CREATE OR REPLACE FUNCTION public.update_updated_at()
    RETURNS TRIGGER AS $$
    BEGIN
        NEW.updated_at = NOW();
        RETURN NEW;
    END;
    $$ LANGUAGE plpgsql;

    DROP TRIGGER IF EXISTS update_auth_users_updated_at ON auth.users;
    CREATE TRIGGER update_auth_users_updated_at
        BEFORE UPDATE ON auth.users
        FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();

    -- =============================================================================
    -- auth.token_blacklist - Persisted revoked tokens
    -- =============================================================================

    CREATE TABLE IF NOT EXISTS auth.token_blacklist (
        id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
        token_hash VARCHAR(64) NOT NULL,
        expires_at TIMESTAMPTZ NOT NULL,
        blacklisted_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
        user_id VARCHAR(36),
        reason VARCHAR(50) DEFAULT 'logout'
    );

    CREATE UNIQUE INDEX IF NOT EXISTS idx_token_blacklist_hash ON auth.token_blacklist(token_hash);
    CREATE INDEX IF NOT EXISTS idx_token_blacklist_expires ON auth.token_blacklist(expires_at);

    -- =============================================================================
    -- audit.security_events - Security event logging (create if not exists)
    -- =============================================================================

    CREATE TABLE IF NOT EXISTS audit.security_events (
        id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
        event_type VARCHAR(100) NOT NULL,
        severity VARCHAR(20) NOT NULL DEFAULT 'info',
        user_id VARCHAR(36),
        ip_address INET,
        message TEXT,
        details JSONB DEFAULT '{}',
        request_id UUID,
        created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );

    CREATE INDEX IF NOT EXISTS idx_security_events_type ON audit.security_events(event_type);
    CREATE INDEX IF NOT EXISTS idx_security_events_severity ON audit.security_events(severity) WHERE severity IN ('high', 'critical');
    CREATE INDEX IF NOT EXISTS idx_security_events_ip ON audit.security_events(ip_address);
    CREATE INDEX IF NOT EXISTS idx_security_events_timestamp ON audit.security_events(created_at DESC);
    ```

    **Step 4: Wire structlog + correlation ID middleware into gathering/api/main.py.**
    - Add import: `from gathering.core.logging import configure_logging`
    - Add import: `from asgi_correlation_id import CorrelationIdMiddleware`
    - In the app lifespan or startup event, call `configure_logging(json_output=not settings.debug)` (use console renderer in debug mode)
    - Add `app.add_middleware(CorrelationIdMiddleware)` BEFORE other middleware (it must run first to set the correlation ID for downstream middleware and handlers)
    - Verify the middleware ordering: CorrelationIdMiddleware should be added last (since Starlette middleware runs in reverse-add order, adding it last means it executes first)

    **IMPORTANT:** Do NOT change the existing middleware ordering for AuthenticationMiddleware or RateLimitMiddleware. Only ADD the CorrelationIdMiddleware.
  </action>
  <verify>
    Run `python -c "from gathering.core.exceptions import AuthenticationError, AuthorizationError, DatabaseError; print('OK')"` -- prints OK.
    Run `python -c "from gathering.core.logging import configure_logging; configure_logging(json_output=False); print('OK')"` -- prints OK without errors.
    Run `ls /home/loc/workspace/gathering/gathering/db/migrations/006_auth_users.sql` -- file exists.
    Run `python -c "from gathering.api.main import app; print('App created OK')"` -- app initializes without import errors.
    Run `pytest tests/test_auth.py -v` -- all tests still pass after main.py changes.
  </verify>
  <done>AuthenticationError/AuthorizationError/DatabaseError exception classes exist. structlog configured with JSON output and correlation IDs. Migration 006_auth_users.sql defines auth.users, auth.token_blacklist, and audit.security_events tables. FastAPI app wires logging and correlation middleware at startup.</done>
</task>

</tasks>

<verification>
1. `python -c "import jwt; from jwt.exceptions import PyJWTError"` succeeds (PyJWT installed)
2. `python -c "from jose import jwt" 2>&1 | grep -i error` confirms python-jose is removed
3. `pytest tests/test_auth.py -v` -- all existing tests pass with new library implementations
4. `python -c "from gathering.core.exceptions import AuthenticationError, AuthorizationError, DatabaseError"` succeeds
5. `python -c "from gathering.core.logging import configure_logging"` succeeds
6. `006_auth_users.sql` exists and contains CREATE TABLE statements for auth.users, auth.token_blacklist, audit.security_events
7. No import errors when loading the FastAPI app
</verification>

<success_criteria>
- PyJWT is the JWT library (python-jose removed)
- Direct bcrypt is the password hasher (passlib removed)
- bcrypt upper bound unpinned
- asgi-correlation-id added as dependency
- All existing auth tests pass with zero changes to test assertions
- AuthenticationError, AuthorizationError, DatabaseError exist in exception hierarchy
- structlog configured with JSON output and request correlation IDs
- Migration SQL ready for auth.users, auth.token_blacklist, audit.security_events tables
</success_criteria>

<output>
After completion, create `.planning/phases/01-auth-security-foundation/01-01-SUMMARY.md`
</output>
