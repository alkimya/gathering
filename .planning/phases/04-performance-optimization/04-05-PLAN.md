---
phase: 04-performance-optimization
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - gathering/api/routers/auth.py
  - gathering/api/routers/agents.py
  - gathering/api/routers/circles.py
  - gathering/api/routers/health.py
  - gathering/api/routers/pipelines.py
  - gathering/api/routers/scheduled_actions.py
  - gathering/api/routers/projects.py
  - gathering/api/routers/settings.py
  - gathering/api/routers/goals.py
  - gathering/api/routers/models.py
  - gathering/api/routers/background_tasks.py
  - gathering/api/routers/conversations.py
  - gathering/api/routers/memories.py
  - gathering/api/routers/tools.py
  - gathering/api/routers/workspace.py
  - gathering/api/routers/lsp.py
  - gathering/api/routers/plugins.py
  - gathering/api/routers/dashboard.py
  - tests/test_rate_limit_tiers.py
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Auth endpoints (login, register, refresh) enforce TIER_AUTH (5/minute) rate limit"
    - "Mutation endpoints (POST/PUT/DELETE) enforce TIER_WRITE (30/minute) rate limit"
    - "Read endpoints (GET listings) enforce TIER_READ (120/minute) rate limit"
    - "Health/status endpoints enforce TIER_HEALTH (300/minute) rate limit"
    - "Exceeding the rate limit returns 429 Too Many Requests with a Retry-After header"
  artifacts:
    - path: "gathering/api/routers/auth.py"
      provides: "Auth endpoints with TIER_AUTH rate limit"
      contains: "limiter.limit"
    - path: "gathering/api/routers/agents.py"
      provides: "Agent endpoints with TIER_READ/TIER_WRITE rate limits"
      contains: "limiter.limit"
    - path: "tests/test_rate_limit_tiers.py"
      provides: "Rate limit tier integration test with 429 + Retry-After"
      contains: "test_rate_limit_returns_429"
  key_links:
    - from: "gathering/api/routers/auth.py"
      to: "gathering/api/rate_limit.py"
      via: "import limiter, TIER_AUTH"
      pattern: "TIER_AUTH"
    - from: "gathering/api/routers/agents.py"
      to: "gathering/api/rate_limit.py"
      via: "import limiter, TIER_READ, TIER_WRITE"
      pattern: "TIER_READ|TIER_WRITE"
    - from: "tests/test_rate_limit_tiers.py"
      to: "gathering/api/main.py"
      via: "create_app with enable_rate_limit=True"
      pattern: "enable_rate_limit"
---

<objective>
Apply per-endpoint rate limit decorators to all route handlers using the tier constants (TIER_AUTH, TIER_WRITE, TIER_READ, TIER_HEALTH) defined in rate_limit.py but currently unused.

Purpose: slowapi is wired into the FastAPI app with a global default limit (120/min), but no individual endpoints have @limiter.limit() decorators. This means auth endpoints (which should be 5/min to prevent brute force) share the same limit as read endpoints (120/min). This plan applies the correct tier to each endpoint and adds a test proving 429 + Retry-After behavior.

Output: All ~100+ route handlers decorated with the appropriate rate limit tier, plus a test proving per-endpoint enforcement.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-performance-optimization/04-02-SUMMARY.md
@gathering/api/rate_limit.py
@gathering/api/routers/auth.py
@gathering/api/routers/agents.py
@gathering/api/routers/health.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Apply @limiter.limit() decorators to all route handlers</name>
  <files>
    gathering/api/routers/auth.py
    gathering/api/routers/agents.py
    gathering/api/routers/circles.py
    gathering/api/routers/health.py
    gathering/api/routers/pipelines.py
    gathering/api/routers/scheduled_actions.py
    gathering/api/routers/projects.py
    gathering/api/routers/settings.py
    gathering/api/routers/goals.py
    gathering/api/routers/models.py
    gathering/api/routers/background_tasks.py
    gathering/api/routers/conversations.py
    gathering/api/routers/memories.py
    gathering/api/routers/tools.py
    gathering/api/routers/workspace.py
    gathering/api/routers/lsp.py
    gathering/api/routers/plugins.py
    gathering/api/routers/dashboard.py
  </files>
  <action>
Apply the correct rate limit tier decorator to every route handler endpoint across all 18 router files.

**CRITICAL: slowapi requires `request: Request` in the endpoint signature.**
Every endpoint that gets a `@limiter.limit()` decorator MUST have `request: Request` as a parameter (can be anywhere in the signature). If it's missing, slowapi silently fails or errors. Add it to every endpoint that doesn't already have it.

**Imports to add to each router file:**
```python
from starlette.requests import Request
from gathering.api.rate_limit import limiter, TIER_AUTH, TIER_WRITE, TIER_READ, TIER_HEALTH
```
(Only import the tiers actually used in that file.)

**Tier assignment rules:**
- **TIER_AUTH (5/minute):** auth.py — login, login_json, register (brute-force protection)
- **TIER_HEALTH (300/minute):** health.py — all health/readiness/liveness endpoints
- **TIER_WRITE (30/minute):** All POST, PUT, PATCH, DELETE endpoints (mutations)
- **TIER_READ (120/minute):** All GET endpoints (reads) — this matches the default_limits but making it explicit on each endpoint documents intent and allows changing the default later

**Decorator placement:** The `@limiter.limit()` decorator goes BETWEEN `@router.method()` and the function definition:
```python
@router.get("/example")
@limiter.limit(TIER_READ)
async def example(request: Request, ...):
    ...
```

**Special cases:**
- **auth.py endpoints** currently don't have `request: Request` — add it as the FIRST parameter after self/form_data. For `login()` which takes `form_data: Annotated[OAuth2PasswordRequestForm, Depends()]`, add `request: Request` before it. For `register()`, add `request: Request` before `user_data`.
- **Endpoints with `Annotated[TokenData, Depends(get_current_active_user)]`** (e.g., /auth/me, /auth/verify, /auth/logout): Use TIER_READ for GET, TIER_WRITE for POST. Add `request: Request` parameter.
- **auth.py /blacklist/stats** (admin-only GET): Use TIER_READ.
- **dashboard.py** endpoints: TIER_READ for all (they're all GETs).
- **websocket.py** — SKIP. WebSocket endpoints don't go through HTTP rate limiting. Only the GET /ws/stats endpoint needs TIER_READ.

**Per-file summary:**

| File | Auth endpoints | Write endpoints | Read endpoints | Health endpoints |
|------|---------------|-----------------|----------------|-----------------|
| auth.py | login, login_json, register | logout, verify | me, blacklist/stats | — |
| health.py | — | — | — | all 5 endpoints |
| agents.py | — | POST/PATCH/DELETE ones | GET ones | — |
| circles.py | — | POST/DELETE ones | GET ones | — |
| conversations.py | — | POST/DELETE ones | GET ones | — |
| models.py | — | POST/PATCH/DELETE ones | GET ones | — |
| pipelines.py | — | POST/PUT/DELETE ones | GET ones | — |
| scheduled_actions.py | — | POST/PATCH/DELETE ones | GET ones | — |
| background_tasks.py | — | POST/DELETE ones | GET ones | — |
| goals.py | — | POST/PATCH/DELETE ones | GET ones | — |
| settings.py | — | PATCH/POST ones | GET ones | — |
| projects.py | — | POST/PATCH/DELETE ones | GET ones | — |
| memories.py | — | POST/DELETE ones | GET ones | — |
| tools.py | — | POST/PATCH ones | GET ones | — |
| workspace.py | — | POST/PUT/DELETE ones | GET ones | — |
| lsp.py | — | POST/DELETE ones | GET ones | — |
| plugins.py | — | POST ones | GET ones | — |
| dashboard.py | — | — | all GETs | — |
| websocket.py | — | — | GET /ws/stats only | — |

Work through each file systematically:
1. Add the imports (Request, limiter, relevant TIER_* constants)
2. Add `@limiter.limit(TIER_X)` decorator to each endpoint
3. Add `request: Request` parameter to each endpoint function signature
4. Do NOT change any business logic — only add decorators and the request parameter
  </action>
  <verify>
    Run `grep -r "limiter.limit" gathering/api/routers/ | wc -l` — should be 100+ (one per endpoint).
    Run `grep -r "TIER_AUTH" gathering/api/routers/auth.py` — should find 3+ matches (login, login_json, register).
    Run `python -c "from gathering.api.main import create_app; app = create_app(enable_auth=False)"` — app creates without errors.
    Run `python -m pytest tests/test_api.py -v` — existing tests still pass (they disable rate limiting via enable_rate_limit=False).
  </verify>
  <done>
    All 18 router files have @limiter.limit() decorators on every endpoint with the correct tier. Every decorated endpoint has `request: Request` in its signature. Auth endpoints use TIER_AUTH, health endpoints use TIER_HEALTH, mutation endpoints use TIER_WRITE, read endpoints use TIER_READ. App creates and existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add rate limit tier integration test with 429 + Retry-After verification</name>
  <files>tests/test_rate_limit_tiers.py</files>
  <action>
Create an integration test that proves per-endpoint rate limits work and 429 + Retry-After is returned.

**Test file: tests/test_rate_limit_tiers.py**

**Setup:**
- Create the app with `enable_rate_limit=True`, `enable_auth=False`, `enable_logging=False`
- Use FastAPI TestClient (sync is fine for rate limit testing)
- Reset the limiter's storage between tests to avoid cross-test pollution

**Test cases:**

1. **test_rate_limit_returns_429_with_retry_after** — The critical test:
   - Target: POST /auth/login (TIER_AUTH = 5/minute)
   - Send 6 rapid requests with invalid credentials (will get 401, that's fine — rate limit still counts)
   - The 6th request should return 429 Too Many Requests
   - Assert response status code == 429
   - Assert "Retry-After" header exists in the response
   - Assert response body contains rate limit information

2. **test_health_endpoint_higher_limit** — Prove health has a different (higher) limit than auth:
   - Target: GET /health (TIER_HEALTH = 300/minute)
   - Send 10 rapid requests to /health
   - ALL 10 should return 200 (well within 300/min)
   - This proves health is NOT subject to the 5/min auth limit

3. **test_read_endpoint_default_tier** — Prove a read endpoint uses TIER_READ:
   - Target: GET /health/ready (TIER_HEALTH = 300/minute)
   - Send 10 requests — all should succeed
   - Confirms the per-endpoint tier is working, not just the global default

4. **test_rate_limit_header_present_on_success** — Even successful requests get rate limit headers:
   - Send 1 request to any endpoint
   - Check for `X-RateLimit-Limit`, `X-RateLimit-Remaining`, `X-RateLimit-Reset` headers (slowapi injects these)

**Limiter storage reset between tests:**
```python
@pytest.fixture(autouse=True)
def reset_limiter_storage():
    from gathering.api.rate_limit import limiter
    limiter.reset()
    yield
```
If `limiter.reset()` doesn't exist, use `limiter._limiter.reset()` or recreate the storage. Check slowapi API. Alternative: create a fresh app per test.

**Important:** The test MUST use the real slowapi middleware (enable_rate_limit=True), not a mock. This is an integration test proving the full chain: decorator -> slowapi -> 429 response -> Retry-After header.
  </action>
  <verify>
    Run `python -m pytest tests/test_rate_limit_tiers.py -v` — all 4 tests pass.
    The 429 test must actually receive a 429 status code with Retry-After header.
  </verify>
  <done>
    4 tests pass: 429 with Retry-After on auth rate limit exceeded, health endpoint allows higher throughput than auth, read endpoint uses its own tier, and rate limit headers present on success. The tests use real slowapi middleware, not mocks.
  </done>
</task>

</tasks>

<verification>
1. `grep -r "limiter.limit" gathering/api/routers/ | wc -l` returns 100+ (decorators on all endpoints)
2. `grep -c "TIER_AUTH" gathering/api/routers/auth.py` returns 3+ (login, login_json, register)
3. `grep -c "TIER_HEALTH" gathering/api/routers/health.py` returns 5 (all health endpoints)
4. `python -m pytest tests/test_rate_limit_tiers.py -v` — all tests pass with real 429 responses
5. `python -m pytest tests/test_api.py -v` — existing tests unaffected (they disable rate limiting)
6. No router file is missing the `request: Request` parameter on decorated endpoints
</verification>

<success_criteria>
- Every route handler across all 18 router files has an @limiter.limit() decorator with the correct tier
- Auth endpoints (login, register) use TIER_AUTH (5/minute)
- Health endpoints use TIER_HEALTH (300/minute)
- Write endpoints use TIER_WRITE (30/minute)
- Read endpoints use TIER_READ (120/minute)
- An integration test proves 429 + Retry-After is returned when rate limit is exceeded
- Existing tests pass without modification
</success_criteria>

<output>
After completion, create `.planning/phases/04-performance-optimization/04-05-SUMMARY.md`
</output>
