---
phase: 04-performance-optimization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - gathering/api/async_db.py
  - gathering/api/main.py
  - gathering/api/dependencies.py
autonomous: true

must_haves:
  truths:
    - "AsyncDatabaseService exists as a FastAPI dependency using pycopg AsyncPooledDatabase"
    - "FastAPI lifespan opens the async pool on startup and closes it on shutdown"
    - "Circle member retrieval executes 1-2 JOINs instead of N+1 individual queries per member"
  artifacts:
    - path: "gathering/api/async_db.py"
      provides: "AsyncDatabaseService singleton with open/close lifecycle"
      contains: "AsyncPooledDatabase"
    - path: "gathering/api/main.py"
      provides: "Async pool lifecycle in lifespan"
      contains: "async_db"
    - path: "gathering/api/dependencies.py"
      provides: "JOIN query replacing N+1 in circle member loading"
      contains: "JOIN agent.agents"
  key_links:
    - from: "gathering/api/async_db.py"
      to: "pycopg.AsyncPooledDatabase"
      via: "import and instantiation"
      pattern: "AsyncPooledDatabase"
    - from: "gathering/api/main.py"
      to: "gathering/api/async_db.py"
      via: "lifespan startup/shutdown"
      pattern: "async_db_service"
    - from: "gathering/api/dependencies.py"
      to: "circle.members JOIN agent.agents"
      via: "single SQL query"
      pattern: "JOIN agent\\.agents"
---

<objective>
Create the async database service and eliminate N+1 queries in circle member retrieval.

Purpose: PERF-01 and PERF-02 -- the two highest-impact database performance fixes. The sync DatabaseService blocks the FastAPI event loop on every query. The N+1 pattern in circle loading fires 2 extra queries per member (get_agent + skill_names SELECT). Both must be fixed for production-viable request latency.

Output: AsyncDatabaseService wired into FastAPI lifespan; circle member loading uses a single JOIN query.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-performance-optimization/04-RESEARCH.md
@gathering/api/dependencies.py
@gathering/api/main.py
@venv/lib/python3.13/site-packages/pycopg/pool.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AsyncDatabaseService and wire into FastAPI lifespan</name>
  <files>gathering/api/async_db.py, gathering/api/main.py</files>
  <action>
Create `gathering/api/async_db.py` with an `AsyncDatabaseService` class:

1. **AsyncDatabaseService class** -- singleton pattern matching existing `DatabaseService`:
   - `__init__`: Parse DATABASE_URL or individual DB_* env vars (same logic as DatabaseService.__init__ in dependencies.py lines 36-60), create `AsyncPooledDatabase(config, min_size=4, max_size=20)` from pycopg.
   - `async startup()`: Call `await self._pool.open()`. Log "Async database pool opened".
   - `async shutdown()`: Call `await self._pool.close()`. Log "Async database pool closed".
   - `async execute(sql, params=None) -> list[dict]`: Delegate to `self._pool.execute(sql, params or [])`.
   - `async execute_one(sql, params=None) -> Optional[dict]`: Delegate to `self._pool.fetch_one(sql, params or [])`.
   - `async fetch_all(sql, params=None)`: Alias for execute.
   - `async fetch_one(sql, params=None)`: Alias for execute_one.
   - Class-level `_instance` with `get_instance()` classmethod (same singleton pattern as DatabaseService).
   - `reset_instance()` classmethod for test isolation.
   - Property `stats` returning pool statistics via `self._pool.stats`.

2. **Add `get_async_db()` function** as a FastAPI dependency:
   ```python
   async def get_async_db() -> AsyncDatabaseService:
       return AsyncDatabaseService.get_instance()
   ```

3. **IMPORTANT**: psycopg 3 (which pycopg wraps) supports `%(name)s` named parameters natively. The existing codebase uses named params throughout (`%(id)s`, `%(name)s`). The `AsyncPooledDatabase.execute()` passes through to psycopg cursors which accept both `%s` positional and `%(name)s` named. No parameter style migration needed.

4. **Wire into FastAPI lifespan** in `gathering/api/main.py`:
   - In the `lifespan()` async generator, after the scheduler start block, add:
     ```python
     # Initialize async database pool
     try:
         from gathering.api.async_db import AsyncDatabaseService
         async_db = AsyncDatabaseService.get_instance()
         await async_db.startup()
         print("Async database pool opened")
     except Exception as e:
         print(f"Warning: Could not initialize async database pool: {e}")
     ```
   - In the shutdown section (after yield), before scheduler stop, add:
     ```python
     # Close async database pool
     try:
         from gathering.api.async_db import AsyncDatabaseService
         if AsyncDatabaseService._instance is not None:
             await AsyncDatabaseService.get_instance().shutdown()
             print("Async database pool closed")
     except Exception as e:
         print(f"Warning: Error during async database pool shutdown: {e}")
     ```

5. Do NOT migrate existing sync routes to use AsyncDatabaseService in this task. The async service is infrastructure -- routers will be migrated incrementally in future work. The goal is to have the pool ready and wired so it is available for any route that wants to `Depends(get_async_db)`.
  </action>
  <verify>
    - `python -c "from gathering.api.async_db import AsyncDatabaseService, get_async_db; print('import ok')"` succeeds
    - `python -c "from gathering.api.main import create_app; app = create_app(); print('app creates ok')"` succeeds
    - Verify lifespan references AsyncDatabaseService startup/shutdown
  </verify>
  <done>AsyncDatabaseService exists as a singleton using pycopg AsyncPooledDatabase, wired into FastAPI lifespan startup/shutdown, with get_async_db dependency function available for route injection.</done>
</task>

<task type="auto">
  <name>Task 2: Eliminate N+1 queries in circle member retrieval</name>
  <files>gathering/api/dependencies.py</files>
  <action>
Fix the N+1 query pattern in `CircleRegistry._load_from_db()` (around line 841) and `ConversationService._load_from_db()` (around line 648) in `gathering/api/dependencies.py`.

**Problem (lines 863-899):** For each circle member, the code calls:
1. `self._db.get_circle_members_with_info(circle_row['id'])` -- returns basic member info (already a JOIN, acceptable)
2. Inside the member loop: `self._db.get_agent(agent_id_local)` -- N+1: fires a complex query per member
3. Inside the member loop: `self._db.execute_one("SELECT skill_names FROM agent.agents WHERE id = %(id)s", ...)` -- another N+1 per member

**Fix:** Replace the inner loop's individual queries with a single batch query that retrieves all member agent details in one shot.

1. **Add a new method to DatabaseService** called `get_circle_members_full(circle_id: int) -> List[Dict]`:
   ```python
   def get_circle_members_full(self, circle_id: int) -> List[Dict]:
       """Get circle members with full agent details in a single JOIN query."""
       return self.execute("""
           SELECT
               m.id as member_id,
               m.agent_id,
               m.role,
               m.is_active,
               m.joined_at,
               a.name as agent_name,
               a.system_prompt,
               a.base_prompt,
               a.skill_names,
               a.status as agent_status,
               p.name as provider_name,
               p.api_type as provider_api_type,
               mod.model_name,
               mod.model_alias
           FROM circle.members m
           JOIN agent.agents a ON a.id = m.agent_id
           LEFT JOIN agent.models mod ON a.model_id = mod.id
           LEFT JOIN agent.providers p ON mod.provider_id = p.id
           WHERE m.circle_id = %(circle_id)s AND m.is_active = true
       """, {'circle_id': circle_id})
   ```

2. **Update `CircleRegistry._load_from_db()`** (the second _load_from_db around line 841):
   - Replace `members = self._db.get_circle_members_with_info(circle_row['id'])` + the per-member loop that calls `get_agent()` and `execute_one()` with:
   - Call `members = self._db.get_circle_members_full(circle_row['id'])` instead
   - Extract `agent_name`, `system_prompt`/`base_prompt`, `skill_names`, `provider_name`, `model_name`/`model_alias` directly from the JOIN result row
   - Remove the individual `self._db.get_agent(agent_id_local)` call
   - Remove the individual `self._db.execute_one("SELECT skill_names ...")` call
   - Keep all the downstream logic (LLM provider creation, prompt building, AgentHandle creation) intact -- just source data from the JOIN row instead of separate queries

3. **Also check `ConversationService._load_from_db()`** (around line 648) for similar N+1 patterns. If it calls `get_agent()` in a loop over members/conversations, apply the same JOIN optimization.

4. **Preserve backward compatibility**: The existing `get_agent()` and `get_circle_members_with_info()` methods remain -- other code may use them. We only change the circle loading path.

**Key constraint**: This uses the sync DatabaseService (not async). The N+1 fix is about query count, not sync/async. Both fixes (async driver + N+1) are independent optimizations.
  </action>
  <verify>
    - `python -c "from gathering.api.dependencies import DatabaseService; print('import ok')"` succeeds
    - Grep for `get_agent(agent_id_local)` inside the circle member loop -- should be removed from _load_from_db around line 888
    - Grep for `get_circle_members_full` -- should exist as a new method
    - `python -m pytest tests/ -x -q --timeout=30 2>&1 | tail -20` -- existing tests still pass
  </verify>
  <done>Circle member retrieval uses a single JOIN query (get_circle_members_full) instead of 2N+1 individual queries per member. The N+1 pattern is eliminated from CircleRegistry._load_from_db().</done>
</task>

</tasks>

<verification>
- AsyncDatabaseService importable and creates pool from env vars
- FastAPI app lifespan opens and closes the async pool
- get_async_db dependency function available for route injection
- Circle member loading uses single JOIN query
- No individual get_agent() calls inside member iteration loop
- All existing tests pass (no regressions)
</verification>

<success_criteria>
1. `from gathering.api.async_db import AsyncDatabaseService, get_async_db` imports cleanly
2. FastAPI lifespan includes async pool startup and shutdown
3. `grep -n "get_circle_members_full" gathering/api/dependencies.py` returns the new JOIN method
4. The circle member loop no longer calls `get_agent()` or `execute_one("SELECT skill_names")` per member
5. `python -m pytest tests/ -x -q --timeout=30` passes
</success_criteria>

<output>
After completion, create `.planning/phases/04-performance-optimization/04-01-SUMMARY.md`
</output>
