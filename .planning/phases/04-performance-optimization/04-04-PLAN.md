---
phase: 04-performance-optimization
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - gathering/api/routers/agents.py
  - gathering/api/routers/health.py
  - gathering/api/routers/circles.py
  - gathering/api/routers/models.py
  - tests/test_async_db_routes.py
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "At least one representative GET route handler uses AsyncDatabaseService via Depends(get_async_db) for non-blocking DB access"
    - "At least one representative POST/mutation route handler uses AsyncDatabaseService via await db.execute() instead of sync db.execute()"
    - "An integration test proves concurrent async DB requests don't serialize on the event loop"
  artifacts:
    - path: "gathering/api/routers/agents.py"
      provides: "Agent history endpoint migrated to async DB"
      contains: "get_async_db"
    - path: "gathering/api/routers/health.py"
      provides: "Health checks endpoint migrated to async DB"
      contains: "get_async_db"
    - path: "tests/test_async_db_routes.py"
      provides: "Integration test proving async DB concurrency"
      contains: "test_concurrent_async_db"
  key_links:
    - from: "gathering/api/routers/agents.py"
      to: "gathering/api/async_db.py"
      via: "Depends(get_async_db)"
      pattern: "get_async_db"
    - from: "gathering/api/routers/health.py"
      to: "gathering/api/async_db.py"
      via: "Depends(get_async_db)"
      pattern: "get_async_db"
---

<objective>
Migrate representative route handlers from sync DatabaseService to AsyncDatabaseService, closing the gap where async DB infrastructure exists but zero routes use it.

Purpose: The AsyncDatabaseService was created in 04-01 with pool lifecycle wired into FastAPI lifespan, but all route handlers still use sync DatabaseService via Depends(get_database_service), blocking the event loop on every query. This plan migrates a representative subset of handlers to prove the pattern works and unblock the event loop for DB-bound requests.

Output: At least 4 route handlers across 2-3 routers using async DB, plus an integration test proving concurrent requests don't serialize.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-performance-optimization/04-01-SUMMARY.md
@gathering/api/async_db.py
@gathering/api/routers/agents.py
@gathering/api/routers/health.py
@gathering/api/routers/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate representative route handlers to AsyncDatabaseService</name>
  <files>
    gathering/api/routers/agents.py
    gathering/api/routers/health.py
    gathering/api/routers/circles.py
    gathering/api/routers/models.py
  </files>
  <action>
Migrate a representative set of route handlers from sync DatabaseService to AsyncDatabaseService. The goal is to cover at least one GET (read) and one POST (write) pattern to prove both directions work.

**Targets for migration (chosen for coverage and simplicity):**

1. **agents.py — `get_agent_history` (GET /{agent_id}/history)**
   - Currently: `db: DatabaseService = Depends(get_database_service)` then `db.execute(sql, params)` (sync)
   - Change to: `db: AsyncDatabaseService = Depends(get_async_db)` then `await db.execute(sql, params)` (async)
   - Import `from gathering.api.async_db import AsyncDatabaseService, get_async_db`
   - The `db.execute()` call on line ~303 becomes `await db.execute()` — same SQL, same params, just awaited
   - Keep the sync DatabaseService import for other endpoints in this file that are NOT being migrated

2. **agents.py — `chat_with_agent` (POST /{agent_id}/chat)**
   - Currently: uses `db: DatabaseService = Depends(get_database_service)` then `db._db.execute()` for INSERT
   - Change to: `db: AsyncDatabaseService = Depends(get_async_db)` then `await db.execute()` for INSERT
   - The two INSERT statements (user message + assistant response) on lines ~368 and ~377 become `await db.execute()`
   - Remove the `db._db.execute()` pattern (accessing private _db attribute) — AsyncDatabaseService.execute() is the public API

3. **health.py — `get_health_checks` (GET /health/checks)**
   - Currently: `db_service: DatabaseService = Depends(get_database_service)` then `db_service.fetch_one("SELECT 1 as ok")` (sync)
   - Change to: `db_service: AsyncDatabaseService = Depends(get_async_db)` then `await db_service.fetch_one("SELECT 1 as ok")` (async)
   - Import `from gathering.api.async_db import AsyncDatabaseService, get_async_db`
   - Only this ONE endpoint in health.py uses DB — the others (health, system, ready, live) don't

4. **models.py — `list_providers` (GET /config/providers)**
   - Currently: `db: DatabaseService = Depends(get_database_service)` then `db.fetch_all()` / `db.fetch_one()` (sync)
   - Change to: `db: AsyncDatabaseService = Depends(get_async_db)` then `await db.fetch_all()` / `await db.fetch_one()` (async)
   - Migrate `list_providers` and `get_provider` (2 simple GET endpoints) as representative read patterns
   - Keep remaining models.py endpoints on sync DB for now — this is gap closure, not full migration

**Important: Do NOT migrate ALL endpoints.** The gap closure requirement is "at least one representative route handler" — we migrate ~5-6 across multiple routers to prove the pattern works at scale. Full migration of all ~100+ endpoints is future work.

**Pattern for each migration:**
```python
# Before:
from gathering.api.dependencies import get_database_service, DatabaseService

async def my_endpoint(db: DatabaseService = Depends(get_database_service)):
    rows = db.execute(sql, params)  # SYNC — blocks event loop

# After:
from gathering.api.async_db import AsyncDatabaseService, get_async_db

async def my_endpoint(db: AsyncDatabaseService = Depends(get_async_db)):
    rows = await db.execute(sql, params)  # ASYNC — non-blocking
```
  </action>
  <verify>
    Run `python -c "from gathering.api.routers.agents import router; print('agents OK')"` and same for health, models — all import without error.
    Grep for `get_async_db` in the modified router files — should find at least 4 occurrences total.
    Grep for `await db.execute` or `await db.fetch` — should find usages in the migrated endpoints.
  </verify>
  <done>
    At least 5 route handler functions across agents.py, health.py, and models.py use AsyncDatabaseService via Depends(get_async_db) with await on all DB calls. The remaining endpoints in those files still use sync DatabaseService (backward compatible). No import errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add integration test proving async DB concurrency</name>
  <files>tests/test_async_db_routes.py</files>
  <action>
Create an integration test that proves async DB route handlers don't block the event loop under concurrent load. This is the verification requirement from the VERIFICATION.md gap.

**Test file: tests/test_async_db_routes.py**

Structure:
1. Import `create_app` from `gathering.api.main`, httpx AsyncClient (or use TestClient with threading)
2. Create the app with auth disabled, rate limiting disabled
3. Use `pytest.mark.asyncio` and httpx `AsyncClient` for true async testing

**Test cases:**

1. **test_async_health_checks_endpoint** — Basic smoke test that GET /health/checks responds 200. Proves the async DB dependency injection works end-to-end. Mock the async_db if PostgreSQL is not available in test env — the goal is to prove the dependency wiring, not the DB connection.

2. **test_concurrent_async_db_requests** — The critical concurrency test:
   - Send 10 concurrent GET requests to an async-DB-backed endpoint (e.g., /health/checks)
   - Use `asyncio.gather()` to fire them simultaneously
   - Assert all 10 return successfully (200 or appropriate status)
   - Measure wall-clock time — 10 concurrent requests should complete in roughly the same time as 1 request (not 10x the time, which would indicate serialization)
   - This proves the event loop is not blocked by sync DB calls

3. **test_async_db_dependency_returns_async_service** — Unit test that `get_async_db()` returns an `AsyncDatabaseService` instance, not a sync `DatabaseService`.

**Mocking strategy:** Since tests may run without a live PostgreSQL, mock `AsyncDatabaseService` at the dependency override level:
```python
app.dependency_overrides[get_async_db] = lambda: mock_async_db
```
where `mock_async_db` has async execute/fetch_one/fetch_all methods that return canned data after a small `asyncio.sleep(0.01)` to simulate real async I/O.

The concurrency test with the sleep mock proves that 10 concurrent "queries" of 10ms each complete in ~10-20ms total (parallel), not ~100ms (serial).
  </action>
  <verify>
    Run `python -m pytest tests/test_async_db_routes.py -v` — all tests pass.
    The concurrent test should complete in under 2 seconds (10 requests with 10ms mock delay each).
  </verify>
  <done>
    3 tests in test_async_db_routes.py pass: smoke test for async endpoint, concurrency test proving parallel execution, and unit test for async dependency. The concurrency test demonstrates that concurrent requests execute in parallel (wall time << sum of individual times), proving the event loop is not blocked.
  </done>
</task>

</tasks>

<verification>
1. `grep -r "get_async_db" gathering/api/routers/` returns matches in agents.py, health.py, and models.py
2. `grep -r "await db\." gathering/api/routers/agents.py` returns matches for the migrated endpoints
3. `python -m pytest tests/test_async_db_routes.py -v` — all tests pass
4. `python -c "from gathering.api.main import create_app; app = create_app(enable_auth=False)"` — app creates without errors
5. No existing tests broken — `python -m pytest tests/test_api.py -v` still passes
</verification>

<success_criteria>
- At least 5 route handler functions use AsyncDatabaseService via Depends(get_async_db) with await
- An integration test proves concurrent async DB requests complete in parallel, not serially
- All existing tests continue to pass (no regressions)
- The async dependency injection pattern is proven end-to-end
</success_criteria>

<output>
After completion, create `.planning/phases/04-performance-optimization/04-04-SUMMARY.md`
</output>
